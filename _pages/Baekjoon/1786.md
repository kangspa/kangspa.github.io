---
title: "찾기"
tags:
    - 2 초
    - 256 MB
    - 31.308%
date: "2025-08-29"
---

출처 : [찾기](https://www.acmicpc.net/problem/1786)
<details>
<summary><b>Solution</b></summary>

<details>
<summary>Python</summary>

<pre><code class='language-python'>
import sys
input = sys.stdin.readline

# 파이배열 : 문자열에서 패턴을 찾고,
# 접두사와 접미사가 해당 위치에서 몇번째까지 같은지 찾는 알고리즘
def piList(pattern):
    n = len(pattern)
    # 파이배열 초기화
    pi = [0]*n
    # i=전체에서 시작위치, j=현재 체크해야할 마지막 위치
    i = 0
    for j in range(1, n):
        # 만약 다를 경우, i가 0이 될 때까지 초기화
        # 초기화는 파이배열에서 이전까지의 반복위치 값을 찾아가며 초기화해준다.
        # 만약 i번째 문자와 j번째 문자가 같다면, 그 순간부터는 다음 값을 비교해준다.
        while i > 0 and pattern[i] != pattern[j]:
            i = pi[i-1]
        # 같으면, i를 1더하고 파이배열에 이전까지의 값은 동일했음을 저장
        if pattern[i] == pattern[j]:
            i += 1
            pi[j]=i
    # 만들어진 파이배열 리턴
    return pi

def KMP(T, P):
    n, m = len(T), len(P)
    # 먼저 파이배열을 만들어서 패턴을 찾는다.
    pi = piList(P)
    # 결과가 저장될 배열
    res = []
    # i=P에서 체크해야하는 값이 있는 위치, j=T에서 체크해야하는 위치
    i = 0
    for j in range(n):
        # 서로 다르다면, 파이배열 찾을 때와 동일하게 진행
        # 같은 문자가 나올 때까지 P에서 비교하는 문자를 하나씩 이전까지 같았던 값으로 변경
        while i > 0 and P[i] != T[j]:
            i = pi[i-1]
        # 서로 같을 경우, P에서 비교하는 문자를 하나씩 더해줌(j는 for문으로 인해 계속 +1 됨)
        if P[i] == T[j]:
            i += 1
            # 만약 P를 끝까지 체크했다면, res에 저장하고 해당위치에서 동일문자가 있던 위치까지 이동
            if i == m:
                res.append(j-i+1)
                i = pi[i-1]
    
    return res

if __name__ == '__main__':
    # strip을 하면 문장 시작이 공백으로 시작할 경우 사라져버림 > rstrip으로!
    T = '0' + input().rstrip()
    P = input().rstrip()
    
    ans = KMP(T, P)
        
    # 출력
    print(len(ans))
    for a in ans:
        print(a, end=' ')
#############################################################
# 해당 방식은 예상했지만 시간 초과임
'''
if __name__ == '__main__':
    T = input().strip()
    P = input().strip()
    
    ansN = 0
    ansIdx = []
    
    while True:
        ans = T.find(P)
        # -1일 경우, T 안에서 P를 찾지 못한다.
        if ans==-1: break
        # 위치를 찾았다면 해당 위치를 저장
        ansN += 1
        # 저장은 가장 마지막 값에서 찾은 인덱스 값을 더해서 진행
        if ansIdx: ansIdx.append(ansIdx[-1]+ans+1)
        # 처음이라면 1을 더해서 저장
        else: ansIdx.append(ans+1)
        # 자르고 다시 체크
        T = T[ans+1:]
    # 출력
    print(ansN)
    for n in ansIdx:
        print(n, end=' ')
'''
</code></pre>
</details>

</details>

<hr>

<div class="col-md-12">
<section class="problem-section" id="description">
<div class="headline">
<h2>문제</h2>
</div>
<div class="problem-text" id="problem_description">
<p>워드프로세서 등을 사용하는 도중에 찾기 기능을 이용해 본 일이 있을 것이다. 이 기능을 여러분이 실제로 구현해 보도록 하자.</p>
<p>두 개의 문자열 P와 T에 대해, 문자열 P가 문자열 T 중간에 몇 번, 어느 위치에서 나타나는지 알아내는 문제를 '문자열 매칭'이라고 한다. 워드프로세서의 찾기 기능은 이 문자열 매칭 문제를 풀어주는 기능이라고 할 수 있다. 이때의 P는 패턴이라고 부르고 T는 텍스트라고 부른다.</p>
<p>편의상 T의 길이를 n, P의 길이를 m이라고 하자. 일반적으로, n ≥ m이라고 가정해도 무리가 없다.  n&lt;m이면 어차피 P는 T중간에 나타날 수 없기 때문이다. 또, T의 i번째 문자를 T[i]라고 표현하도록 하자. 그러면 물론, P의 i번째 문자는 P[i]라고 표현된다.</p>
<pre>
      1 2 3 4 5 6 7 8 9 …
T : [ A B C D A B C D A B D E ]
      | | | | | | X
P : [ A B C D A B D ]
      1 2 3 4 5 6 7</pre>
<p>문자열 P가 문자열 T 중간에 나타난다는 것, 즉 문자열 P가 문자열 T와 매칭을 이룬다는 것이 어떤 것인지 위와 아래의 두 예를 통해 알아보자. 위의 예에서 P는, T의 1번 문자에서 시작하는 매칭에 실패했다. T의 7번 문자 T[7]과, P의 7번 문자 P[7]이 서로 다르기 때문이다.</p>
<p>그러나 아래의 예에서 P는, T의 5번 문자에서 시작하는 매칭에 성공했다. T의 5～11번 문자와 P의 1～7번 문자가 서로 하나씩 대응되기 때문이다.</p>
<pre>
      1 2 3 4 5 6 7 8 9 …
T : [ A B C D A B C D A B D E ]
              | | | | | | |
P :         [ A B C D A B D ]
              1 2 3 4 5 6 7</pre>
<p>가장 단순한 방법으로, 존재하는 모든 매칭을 확인한다면, 시간복잡도가 어떻게 될까? T의 1번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 1～m번 문자와 P의 1～m번 문자를 비교한다면 최대 m번의 연산이 필요하다. 이 비교들이 끝난 후, T의 2번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 2～m+1번 문자와 P의 1～m번 문자를 비교한다면 다시 최대 m번의 연산이 수행된다. 매칭은 T의 n-m+1번 문자에서까지 시작할 수 있으므로, 이러한 방식으로 진행한다면 O( (n-m+1) × m ) = O(nm) 의 시간복잡도를 갖는 알고리즘이 된다.</p>
<p>더 좋은 방법은 없을까? 물론 있다. 위에 제시된 예에서, T[7] ≠ P[7] 이므로 T의 1번 문자에서 시작하는 매칭이 실패임을 알게 된 순간으로 돌아가자. 이때 우리는 매칭이 실패라는 사실에서, T[7] ≠ P[7] 라는 정보만을 얻은 것이 아니다. 오히려 i=1…6에 대해 T[i] = P[i] 라고 하는 귀중한 정보를 얻지 않았는가? 이 정보를 십분 활용하면, O(n)의 시간복잡도 내에 문자열 매칭 문제를 풀어내는 알고리즘을 설계할 수 있다.</p>
<p>P 내부에 존재하는 문자열의 반복에 주목하자. P에서 1, 2번 문자 A, B는 5, 6번 문자로 반복되어 나타난다. 또, T의 1번 문자에서 시작하는 매칭이 7번 문자에서야 실패했으므로 T의 5, 6번 문자도 A, B이다.</p>
<p>따라서 T의 1번 문자에서 시작하는 매칭이 실패한 이후, 그 다음으로 가능한 매칭은 T의 5번 문자에서 시작하는 매칭임을 알 수 있다! 더불어, T의 5～6번 문자는 P의 1～2번 문자와 비교하지 않아도, 서로 같다는 것을 이미 알고 있다! 그러므로 이제는 T의 7번 문자와 P의 3번 문자부터 비교해 나가면 된다.</p>
<p>이제 이 방법을 일반화 해 보자. T의 i번 문자에서 시작하는 매칭을 검사하던 중 T[i+j-1] ≠ P[j]임을 발견했다고 하자. 이렇게 P의 j번 문자에서 매칭이 실패한 경우, P[1…k] = P[j-k…j-1]을 만족하는 최대의 k(≠j-1)에 대해 T의 i+j-1번 문자와 P의 k+1번 문자부터 비교를 계속해 나가면 된다.</p>
<p>이 최대의 k를 j에 대한 함수라고 생각하고, 1～m까지의 각 j값에 대해 최대의 k를 미리 계산해 놓으면 편리할 것이다. 이를 전처리 과정이라고 부르며, O(m)에 완료할 수 있다.</p>
<p>이러한 원리를 이용하여, T와 P가 주어졌을 때, 문자열 매칭 문제를 해결하는 프로그램을 작성하시오.</p>
</div>
</section>
</div>
<div class="col-md-12">
<section class="problem-section" id="input">
<div class="headline">
<h2>입력</h2>
</div>
<div class="problem-text" id="problem_input">
<p>첫째 줄에 문자열 T가, 둘째 줄에 문자열 P가 주어진다. T와 P의 길이 n, m은 1이상 100만 이하이고, 알파벳 대소문자와 공백으로만 이루어져 있다.</p>
</div>
</section>
</div>
<div class="col-md-12">
<section class="problem-section" id="output">
<div class="headline">
<h2>출력</h2>
</div>
<div class="problem-text" id="problem_output">
<p>첫째 줄에, T 중간에 P가 몇 번 나타나는지를 나타내는 음이 아닌 정수를 출력한다. 둘째 줄에는 P가 나타나는 위치를 차례대로 공백으로 구분해 출력한다. 예컨대, T의 i～i+m-1번 문자와 P의 1～m번 문자가 차례로 일치한다면, i를 출력하는 식이다.</p>
</div>
</section>
</div>
<div class="col-md-12">
<section class="problem-section" id="limit" style="display:none;">
<div class="headline">
<h2>제한</h2>
</div>
<div class="problem-text" id="problem_limit">
</div>
</section>
</div>
<div class="col-md-12">
<div class="row">
<div class="col-md-6">
<section id="sampleinput1">
<div class="headline">
<h2>예제 입력 1
							<button class="btn btn-link copy-button" data-clipboard-target="#sample-input-1" style="padding: 0px;" type="button">복사</button>
</h2>
</div>
<pre class="sampledata" id="sample-input-1">ABC ABCDAB ABCDABCDABDE
ABCDABD
</pre>
</section>
</div>
<div class="col-md-6">
<section id="sampleoutput1">
<div class="headline">
<h2>예제 출력 1
							<button class="btn btn-link copy-button" data-clipboard-target="#sample-output-1" style="padding: 0px;" type="button">복사</button>
</h2>
</div>
<pre class="sampledata" id="sample-output-1">1
16
</pre>
</section>
</div>
</div>
</div>
<div class="col-md-12">
<section class="problem-section" id="hint" style="display: none;">
<div class="headline">
<h2>힌트</h2>
</div>
<div class="problem-text" id="problem_hint">
</div>
</section>
</div>
